/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** No-op function to measure BigInt parameter overhead */
export declare function bigintNoop(num: bigint): void
/** No-op function to measure buffer parameter overhead (slice) */
export declare function bufferNoop(buffer: Uint8Array): void
/** No-op function to measure Uint8Array parameter overhead */
export declare function uint8ArrayNoop(buffer: Uint8Array): void
/** No-op with both params to measure combined overhead */
export declare function bothNoop(num: bigint, buffer: Uint8Array): void
/** No-op with BigInt and slice params */
export declare function bothSliceNoop(num: bigint, buffer: Uint8Array): void
/** Simple test - just zero the buffer */
export declare function testZero(buffer: Uint8Array): void
/** Fast BigInt to BE buffer using slice (avoids Uint8Array overhead) */
export declare function toBufferBeFast(num: bigint, buffer: Uint8Array): void
/** Fast BigInt to LE buffer using slice (avoids Uint8Array overhead) */
export declare function toBufferLeFast(num: bigint, buffer: Uint8Array): void
/**
 * Convert a big-endian buffer to BigInt.
 *
 * # Arguments
 * * `buffer` - Big-endian byte buffer (accepts Buffer or Uint8Array)
 *
 * # Returns
 * BigInt value
 *
 * # Example
 * ```javascript
 * const { toBigIntBe } = require('@vekexasia/bigint-buffer2');
 * const buf = Buffer.from([0x01, 0x02, 0x03, 0x04]);
 * const num = toBigIntBe(buf); // 16909060n
 * ```
 */
export declare function toBigintBe(buffer: Uint8Array): bigint
/**
 * Convert a little-endian buffer to BigInt.
 *
 * # Arguments
 * * `buffer` - Little-endian byte buffer (accepts Buffer or Uint8Array)
 *
 * # Returns
 * BigInt value
 */
export declare function toBigintLe(buffer: Uint8Array): bigint
/**
 * Convert a BigInt to big-endian buffer with specified width.
 *
 * # Arguments
 * * `num` - BigInt value to convert
 * * `width` - Desired buffer width in bytes
 *
 * # Returns
 * Big-endian buffer of exactly `width` bytes
 *
 * # Example
 * ```javascript
 * const { toBufferBe } = require('@vekexasia/bigint-buffer2');
 * const buf = toBufferBe(16909060n, 4); // Buffer [0x01, 0x02, 0x03, 0x04]
 * ```
 */
export declare function toBufferBe(num: bigint, width: number): Buffer
/**
 * Convert a BigInt to little-endian buffer with specified width.
 *
 * # Arguments
 * * `num` - BigInt value to convert
 * * `width` - Desired buffer width in bytes
 *
 * # Returns
 * Little-endian buffer of exactly `width` bytes
 */
export declare function toBufferLe(num: bigint, width: number): Buffer
/**
 * Convert a BigInt to big-endian bytes, writing directly into a provided buffer.
 *
 * This is an optimized version that avoids buffer allocation by writing
 * directly into a pre-allocated buffer from JavaScript.
 *
 * # Arguments
 * * `num` - BigInt value to convert
 * * `buffer` - Pre-allocated buffer to write into (width is inferred from length)
 *
 * # Example
 * ```javascript
 * const { toBufferBeInto } = require('@vekexasia/bigint-buffer2');
 * const buf = Buffer.alloc(4);
 * toBufferBeInto(16909060n, buf); // buf is now [0x01, 0x02, 0x03, 0x04]
 * ```
 */
export declare function toBufferBeInto(num: bigint, buffer: Uint8Array): void
/**
 * Convert a BigInt to little-endian bytes, writing directly into a provided buffer.
 *
 * # Arguments
 * * `num` - BigInt value to convert
 * * `buffer` - Pre-allocated buffer to write into (width is inferred from length)
 */
export declare function toBufferLeInto(num: bigint, buffer: Uint8Array): void
